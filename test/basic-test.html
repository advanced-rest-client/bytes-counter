<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../fetch-polyfill/fetch-polyfill.html">
    <link rel="import" href="../bytes-counter.html">
  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <bytes-counter></bytes-counter>
      </template>
    </test-fixture>

    <test-fixture id="stringPromise">
      <template>
        <bytes-counter value="test"></bytes-counter>
      </template>
    </test-fixture>
    <test-fixture id="numberPromise">
      <template>
        <bytes-counter value="2"></bytes-counter>
      </template>
    </test-fixture>

    <script>
    /* global fixture, assert */
    /* jshint esnext: true */
    suite('calculateBytesString', () => {
      var element;
      setup(() => {
        element = fixture('basic');
      });

      test('value is undefined', () => {
        assert.isUndefined(element.value);
      });

      test('bytes is undefined', () => {
        assert.isUndefined(element.bytes);
      });
    });

    function performMapTest(element, map, fnCall) {
      const iterator = map.entries();
      while (true) {
        const entry = iterator.next();
        if (entry.done) {
          break;
        }
        const item = entry.value;
        const size = element[fnCall](item[0]);
        assert.equal(size, item[1][0], 'Size of "' + item[0] + '" equals ' + item[1][0] + ': ' + item[1][1]);
      }
    }

    // function skipWithoutFormDataUnless() {
    //   return (('Request' in window) && typeof Request.prototype.arrayBuffer !== 'undefined');
    // }

    //TestHelpers.skipUnless(skipWithoutFormDataUnless, function {})

    function getBuffer(text) {
      let value;
      if ('TextEncoder' in window) {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(text);
        value = encoded.buffer;
      } else {
        const str = text;
        value = new ArrayBuffer(str.length*2); // 2 bytes for each char
        const bufView = new Uint16Array(value);
        for (let i = 0, strLen = str.length; i < strLen; i++) {
          bufView[i] = str.charCodeAt(i);
        }
      }
      return value;
    }

    suite('stringBytes()', () => {
      let element;
      const model = new Map([
        ['a', [1, 'a has size 1']],
        ['ł', [2, 'ł has size 2']],
        ['1', [1, '1 has size 1']]
      ]);
      setup(() => {
        element = fixture('basic');
      });

      test('computes size of input', () => {
        performMapTest(element, model, 'stringBytes');
      });
    });

    suite('blobBytes()', () => {
      let element;
      const model = new Map([
        [new Blob(['a']), [1, 'a has size 1']],
        [new Blob(['ą']), [2, 'ą has size 2']],
        [new Blob(['1']), [1, '1 has size 1']]
      ]);
      setup(() => {
        element = fixture('basic');
      });

      test('computes size of input', () => {
        performMapTest(element, model, 'blobBytes');
      });
    });

    suite('bufferBytes()', () => {
      let element;
      const model = new Map([
        [getBuffer('a'), [1, 'a has size 1']],
        [getBuffer('ą'), [2, 'ą has size 2']],
        [getBuffer('1'), [1, '1 has size 1']]
      ]);
      setup(() => {
        element = fixture('basic');
      });

      test('computes size of input', () => {
        performMapTest(element, model, 'bufferBytes');
      });
    });

    suite('Auto compute', () => {
      test('Computes string value', (done) => {
        const element = fixture('stringPromise');
        element.addEventListener('bytes-changed', (e) => {
          assert.equal(e.detail.value, '4');
          done();
        });
      });
      test('Computes number value', (done) => {
        const element = fixture('numberPromise');
        element.addEventListener('bytes-changed', (e) => {
          assert.equal(e.detail.value, '1');
          done();
        });
      });
    });
    </script>

  </body>
</html>
