<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../fetch-polyfill/fetch-polyfill.html">
    <link rel="import" href="../bytes-counter.html">
  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <bytes-counter></bytes-counter>
      </template>
    </test-fixture>

    <test-fixture id="stringPromise">
      <template>
        <bytes-counter value="test"></bytes-counter>
      </template>
    </test-fixture>

    <test-fixture id="numberPromise">
      <template>
        <bytes-counter value="2"></bytes-counter>
      </template>
    </test-fixture>

    <script>
    /* global fixture, assert */
    /* jshint esnext: true */
    suite('calculateBytesString', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });

      test('value is undefined', () => {
        assert.isUndefined(element.value);
      });

      test('bytes is undefined', () => {
        assert.isUndefined(element.bytes);
      });
    });

    function performMapTest(element, map, fnCall) {
      const iterator = map.entries();
      while (true) {
        const entry = iterator.next();
        if (entry.done) {
          break;
        }
        const item = entry.value;
        const size = element[fnCall](item[0]);
        assert.equal(size, item[1][0], 'Size of "' + item[0] + '" equals ' + item[1][0] + ': ' + item[1][1]);
      }
    }

    // function skipWithoutFormDataUnless() {
    //   return (('Request' in window) && typeof Request.prototype.arrayBuffer !== 'undefined');
    // }

    function getBuffer(text) {
      let value;
      if ('TextEncoder' in window) {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(text);
        value = encoded.buffer;
      } else {
        const str = text;
        value = new ArrayBuffer(str.length * 2); // 2 bytes for each char
        const bufView = new Uint16Array(value);
        for (let i = 0, strLen = str.length; i < strLen; i++) {
          bufView[i] = str.charCodeAt(i);
        }
      }
      return value;
    }

    suite('stringBytes()', () => {
      let element;
      const model = new Map([
        ['a', [1, 'a has size 1']],
        ['ł', [2, 'ł has size 2']],
        ['1', [1, '1 has size 1']],
        ['�', [3, '� has size 3']]
      ]);
      setup(() => {
        element = fixture('basic');
      });

      test('computes size of input', () => {
        performMapTest(element, model, 'stringBytes');
      });
    });

    suite('blobBytes()', () => {
      let element;
      const model = new Map([
        [new Blob(['a']), [1, 'a has size 1']],
        [new Blob(['ą']), [2, 'ą has size 2']],
        [new Blob(['1']), [1, '1 has size 1']]
      ]);
      setup(() => {
        element = fixture('basic');
      });

      test('computes size of input', () => {
        performMapTest(element, model, 'blobBytes');
      });
    });

    suite('bufferBytes()', () => {
      let element;
      const model = new Map([
        [getBuffer('a'), [1, 'a has size 1']],
        [getBuffer('ą'), [2, 'ą has size 2']],
        [getBuffer('1'), [1, '1 has size 1']]
      ]);
      setup(() => {
        element = fixture('basic');
      });

      test('computes size of input', () => {
        performMapTest(element, model, 'bufferBytes');
      });
    });

    suite('Auto compute', () => {
      test('Computes string value', (done) => {
        const element = fixture('stringPromise');
        element.addEventListener('bytes-changed', (e) => {
          assert.equal(e.detail.value, '4');
          done();
        });
      });
      test('Computes number value', (done) => {
        const element = fixture('numberPromise');
        element.addEventListener('bytes-changed', (e) => {
          assert.equal(e.detail.value, '1');
          done();
        });
      });
    });

    suite('_bodyToArrayBuffer()', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });

      test('Transforms Blob to array buffer', () => {
        return element._bodyToArrayBuffer(new Blob(['a']))
        .then((result) => {
          assert.typeOf(result, 'arraybuffer');
        });
      });

      test('Transforms String to array buffer', () => {
        return element._bodyToArrayBuffer('test')
        .then((result) => {
          assert.typeOf(result, 'arraybuffer');
        });
      });

      // test('Transforms FormData to array buffer', () => {
      //   const fd = new FormData();
      //   fd.append('a', 'b');
      //   return element._bodyToArrayBuffer(fd)
      //   .then((result) => {
      //     assert.typeOf(result, 'arraybuffer');
      //   });
      // });

      test('Rejects when Request is not defined', () => {
        const orig = window.Request;
        window.Request = undefined;
        return element._bodyToArrayBuffer('test')
        .then(() => {
          throw new Error('Should reject promise');
        })
        .catch((cause) => {
          window.Request = orig;
          assert.equal(cause.message, 'Your browser do not support Fetch API.');
        });
      });
    });

    suite('_handleBuffer()', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });

      test('Rejects when no argument', () => {
        return element._handleBuffer()
        .then(() => {
          throw new Error('Should reject promise');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Your browser do not support Fetch API.');
        });
      });

      test('Reads size of the buffer', () => {
        const buffer = new Uint16Array([1, 2, 3]).buffer;
        return element._handleBuffer(buffer)
        .then((result) => {
          assert.equal(result, 6);
        });
      });
    });

    suite('calculate()', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });

      test('Resolves to 0 when no argument', () => {
        return element.calculate()
        .then((result) => {
          assert.equal(result, 0);
        });
      });

      test('Resolves to 0 when argument is undefined', () => {
        return element.calculate(null)
        .then((result) => {
          assert.equal(result, 0);
        });
      });

      test('Resolves to 0 when argument is null', () => {
        return element.calculate(null)
        .then((result) => {
          assert.equal(result, 0);
        });
      });

      test('Resolves to size of string', () => {
        return element.calculate('test')
        .then((result) => {
          assert.equal(result, 4);
        });
      });

      test('Resolves to size of Blob', () => {
        const input = new Blob(['a']);
        return element.calculate(input)
        .then((result) => {
          assert.equal(result, 1);
        });
      });

      test('Resolves to size of ArrayBuffer', () => {
        const input = new ArrayBuffer(6);
        return element.calculate(input)
        .then((result) => {
          assert.equal(result, 6);
        });
      });

      // test('Resolves to size of FormData', () => {
      //   const fd = new FormData();
      //   fd.append('a', 'b');
      //   return element.calculate(fd)
      //   .then((result) => {
      //     assert.isAbove(result, 0);
      //   });
      // });

      test('Resolves to size of casted string', () => {
        return element.calculate(2)
        .then((result) => {
          assert.equal(result, 1);
        });
      });
    });
    </script>

  </body>
</html>
