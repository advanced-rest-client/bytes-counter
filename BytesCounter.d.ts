/**
 * DO NOT EDIT
 *
 * This file was automatically generated by
 *   https://github.com/Polymer/tools/tree/master/packages/gen-typescript-declarations
 *
 * To modify these typings, edit the source file(s):
 *   BytesCounter.js
 */


// tslint:disable:variable-name Describing an API that's defined elsewhere.
// tslint:disable:no-any describes the API as best we are able today

export {BytesCounter};

declare namespace LogicElements {

  /**
   * An element that computes number of bytes in `String`, `ArrayBuffer`, `Blob`
   * (and therefore `File`) and - in supported browsers - from `FormData`.
   *
   * Note that Safari is excluded from FormData tests because there's some bug in
   * WebKit iplementation of the Request object and it doesn't read FormData
   * properly. Chrome had similar bug but they fixed it already. See demo page
   * to check if your browser support FormData.
   *
   * This element is native web component without using any library.
   * Do not set attributes as this element do not observe changes to any. Use templating
   * system of your choice to set a property on the element or use it imperatively.
   *
   * ## Example
   *
   * ### In a Polymer template
   *
   * ```html
   * <textarea value="{{value::input}}"></textarea>
   * <bytes-counter value="[[value]]" bytes="{{bytes}}"></bytes-counter>
   * ```
   *
   * ### In a LitElement template
   *
   * ```htlm
   * import { LitElement, html } from 'lit-element';
   * import '@advanced-rest-client/bytes-counter/bytes-counter.js';
   *
   * class SampleElement extends LitElement {
   *   render() {
   *     return html`
   *     <textarea oninput="${this._inputHandler}"></textarea>
   *     <bytes-counter .value="${this.value}" onchange="${this._computeHandler}"></bytes-counter>
   *     `;
   *   }
   *
   *   _inputHandler(e) {
   *     const { value } = e.target;
   *     this.value = value;
   *   }
   *
   *   _computeHandler(e) {
   *     const { value } = e.detail;
   *     console.log(`Computed input size is ${value} bytes`);
   *   }
   * }
   * customElements.define('sample-element', SampleElement);
   * ```
   *
   * ### Imperative use
   *
   * ```html
   * <textarea id="i1"></textarea>
   * <bytes-counter id="b1"></bytes-counter>
   * <output id="o1"></output>
   * <script>
   * {
   *   document.getElementById('i1').addEventListener('input', (e) => {
   *     const { value } = e.target;
   *     document.getElementById('b1').value = value;
   *   });
   *   document.getElementById('b1').addEventListener('bytes-changed', (e) => {
   *     const { value } = e.detail;
   *     document.getElementById('o1').value = `Current input has ${value} bytes`;
   *   });
   * }
   * </script>
   * ```
   *
   * In the example above the `bytes` variable contains size of the input.
   *
   * Note that computations are synchronous and there is a delay between setting the
   * `value` property (or calling `calculate()` function) and getting a result.
   *
   * ## New in version 3
   *
   * - Dropped support for Polymer library. It is not plain web component.
   * - Added `aria-hidden` attribute
   */
  class BytesCounter extends HTMLElement {
    value: String|Blob|ArrayBuffer|FormData|null;
    readonly bytes: Number|null;
    _bytes: any;
    connectedCallback(): void;

    /**
     * Called when `value` property changed. Asynchronusly calls `_computeValueSize()`
     * function.
     */
    _valueChanged(): void;

    /**
     * Computes the size of passed value and sets `bytes` property.
     */
    _computeValueSize(): Promise<any>|null;

    /**
     * Calculates number of bytes in the `value`.
     *
     * After computation it sets `bytes` property of the element.
     *
     * This function returns Promise but you may want to use synchronous versions
     * for values that contains a method to read size synchronously. Not all
     * values can be processed synchronously (FormData for example).
     *
     * @param value A value to compute
     * number of bytes from.
     * @returns Promise with number of bytes in the `value`. If
     * the `value` is not one of the supported types then the promise will
     * resolve to `undefined`;
     */
    calculate(value: String|ArrayBuffer|Blob|File|FormData|null): Promise<Number|null>;

    /**
     * Handles buffer size calculation.
     *
     * @param buffer Buffer created from the body.
     * @returns Promise resolved to number of bytes in the buffer.
     */
    _handleBuffer(buffer: ArrayBuffer|null): Promise<any>|null;

    /**
     * Calculates number of bytes in string.
     *
     * See: http://stackoverflow.com/a/23329386/1127848
     *
     * @param str A value to evaluate
     * @returns Number of bytes in the string.
     */
    stringBytes(str: String|null): Number|null;

    /**
     * Calculates number of bytes in Blob (and therefore in File).
     *
     * @param blob A value to evaluate
     * @returns Number of bytes in the blob.
     */
    blobBytes(blob: Blob|File|null): Number|null;

    /**
     * Calculates number of bytes in ArrayBuffer.
     *
     * Note, it is only possible to read number of allocated bytes by the buffer,
     * even if they are not containig any value. It is a size of the buffer at
     * the time it was created.
     *
     * @param buffer A value to evaluate
     * @returns Number of bytes in the buffer.
     */
    bufferBytes(buffer: ArrayBuffer|null): Number|null;

    /**
     * Transfer any object that is acceptable as a bidy parameter in the Request
     * object to ArrayBuffer.
     *
     * @param body An object
     * to pass to the Request object as a body property.
     * @returns Resolved promise with the ArrayBuffer. It will reject
     * if the browser doesn't support this method.
     */
    _bodyToArrayBuffer(body: Blob|BufferSource|FormData|URLSearchParams|String|null): Promise<any>|null;
  }
}
